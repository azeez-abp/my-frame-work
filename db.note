CREATE TABLE table_name (
    column1 datatype constraint,
    column2 datatype constraint,
    column3 datatype constraint, constraint

);

e.g
CREATE TABLE table_name (
    column1 datatype NOT NULL,
    column2 datatype UNIQUE,
    column3 datatype PRIMARY KEY NULLABLE,

);
table compose of column ( column compose of name (name compose of  datatype constraint ) )
we insert row into the column

The following constraints are commonly used in SQL:
NOT NULL - Ensures that a column cannot have a NULL value
UNIQUE - Ensures that all values in a column are different
PRIMARY KEY - A combination of a NOT NULL and UNIQUE. Uniquely identifies each row in a table
FOREIGN KEY - Prevents actions that would destroy links between tables
CHECK - Ensures that the values in a column satisfies a specific condition
DEFAULT - Sets a default value for a column if no value is specified
CREATE INDEX - Used to create and retrieve data from the database very quickly


////////////////////////////////////////////////////////////////////////////////////////////

SELECT - extracts data from a database
UPDATE - updates data in a database
DELETE - deletes data from a database
INSERT INTO - inserts new data into a database
CREATE DATABASE - creates a new database
ALTER DATABASE - modifies a database
CREATE TABLE - creates a new table
ALTER TABLE - modifies a table
DROP TABLE - deletes a table
CREATE INDEX - creates an index (search key)
DROP INDEX - deletes an index
TRUNCATE
The MySQL AND, OR and NOT Operators
MySQL ORDER BY Keyword
IS NULL no value field
///////////////////////////////
SELECT MAX(column_name)
FROM table_name
WHERE condition;

WHERE columnN LIKE pattern;


SELECT OrderID, Quantity,
CASE
---- WHEN Quantity > 30 THEN 'The quantity is greater than 30'
---- WHEN Quantity = 30 THEN 'The quantity is 30'
--- ELSE 'The quantity is under 30'
END AS QuantityText
FROM OrderDetails;
////////////////////////

ln -s public public_html (this command link public to public html)

ssh-keygen -t ed25519 -C "adeez@gmail.com"
Get-Service ssh-agent | Select StartType

/////////////////////////////////////////////////////////////////////////////////////////////

Virtual Network service enables Azure resources to securely communicate with each other in a virtual network which is a logical isolation of the Azure cloud dedicated to your subscription. You can connect virtual networks to other virtual networks, or your on-premises network.


polymorphic relation
  from migration 
  Schema::create('comments', function (Blueprint $table) {
    $table->id();
    $table->text('body');
      #major two attr   any table with this, other table will relate to it  (it model will have 
      #a method commentable that return $this->morphTo()) 
    $table->unsignedBigInteger('commentable_id');
    $table->string('commentable_type'); 
      #major two attr
    $table->timestamps();
});

class that define the relationship
class Comment extends Model
{
    public function commentable()
    {
        return $this->morphTo();
    }
}



In the related models (Post and Photo), you need to define the inverse of the polymorphic relationship using the morphMany() | morphOne() method

class Post extends Model
{
    public function comments()
    {
        return $this->morphMany(Comment::class, 'commentable');
    }
}

class Photo extends Model
{
    public function comments()
    {
        return $this->morphMany(Comment::class, 'commentable');Photo has Comment
    }
}

$post = Post::find(1);
$comments = $post->comments;




many to many relationship is achieve through tags (tags belong to many to many relationship)

Here are the steps to create a many-to-many polymorphic relation in Laravel:


    1. Create the database tables
      Create a table for the main entity, e.g. posts.
      Create a table for the related entities, e.g. tags and categories,user_id.
      Create a pivot table to store the relationships, e.g. taggables and categorizables, user_idables.

    2.Define the relationships in the model classes:
      In the Post model, define a morphToMany() relationship with the Tag and Category models.
      In the Tag and Category models, define a morphedByMany() relationship with the Post model.


Schema::create('taggables', function (Blueprint $table) { # this is pivot table
    $table->unsignedBigInteger('tag_id');
    $table->unsignedBigInteger('taggable_id');
    $table->string('taggable_type');
    $table->timestamps();
    $table->foreign('tag_id')->references('id')->on('tags')->onDelete('cascade');
    $table->unique(['tag_id', 'taggable_id', 'taggable_type']);
    $table->index(['tag_id', 'taggable_id', 'taggable_type']);
});

Here's an example code for defining the relationships in the model classes:

class Post extends Model
{
    public function tags()
    {
        return $this->morphToMany(Tag::class, 'taggable');
    }

    public function categories()
    {
        return $this->morphToMany(Category::class, 'categorizable');
    }
}

class Tag extends Model
{
    public function posts()
    {
        return $this->morphedByMany(Post::class, 'taggable');
    }
}

class Category extends Model
{
    public function posts()
    {
        return $this->morphedByMany(Post::class, 'categorizable');
    }
    
}


 the Tag model's morphToMany(Tag::class, 'taggable') method is used to define a many-to-many polymorphic relationship between the Tag model and other models that can be tagged, and it specifies that the relationship should use the pivot table named taggables and the morph name 'taggable'.

CREATE TABLE orders (
  id INT PRIMARY KEY,
  customer_id INT,
  total DECIMAL(10, 2),
  FOREIGN KEY (customer_id) REFERENCES customers(id)
  ON DELETE CASCADE
);

CREATE INDEX idx_orders_customer_id <index name> ON orders<table> (customer_id<column>);

Database execusion plan
sargable query: prevent use of function

SELECT
FROM
JOIN
ON
WHERE
GROUP BY
HAVING
ORDER BY
LIMIT

<> means !=


<?php
$servername = "localhost";
$username = "username";
$password = "password";
$dbname = "myDBPDO";

try {
  $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password);
  // set the PDO error mode to exception
  $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

  // begin the transaction
  $conn->beginTransaction();
  // our SQL statements
  $conn->exec("INSERT INTO MyGuests (firstname, lastname, email)
  VALUES ('John', 'Doe', 'john@example.com')");
  $conn->exec("INSERT INTO MyGuests (firstname, lastname, email)
  VALUES ('Mary', 'Moe', 'mary@example.com')");
  $conn->exec("INSERT INTO MyGuests (firstname, lastname, email)
  VALUES ('Julie', 'Dooley', 'julie@example.com')");

  // commit the transaction
  $conn->commit();
  echo "New records created successfully";
} catch(PDOException $e) {
  // roll back the transaction if something failed
  $conn->rollback();
  echo "Error: " . $e->getMessage();
}


$conn = null;