Accessibility
Code-Splitting
Context
Error Boundaries
Forwarding Refs
Fragments
Higher-Order Components
Integrating with Other Libraries
JSX In Depth
Optimizing Performance
Portals
Profiler
React Without ES6
React Without JSX
Reconciliation
Refs and the DOM
Render Props
Static Type Checking
Strict Mode
Typechecking With PropTypes
Uncontrolled Components
Web Components

Why Accessibility?
Web accessibility (also referred to as a11y) is the design and creation of websites that can be used by everyone. Accessibility support is necessary to allow assistive technology to interpret web pages.

React fully supports building accessible websites, often by using standard HTML techniques.

The Web Content Accessibility Guidelines provides guidelines for creating accessible web sites.(Waht are the guide line)
accessibility laws in the world, are based on four principles:

Perceivable: Available to the senses (vision and hearing primarily) either through the browser or through assistive technologies (e.g. screen readers, screen enlargers, etc.)

Operable: Users can interact with all controls and interactive elements using either the mouse, keyboard, or an assistive device.

Understandable: Content is clear and limits confusion and ambiguity.

Robust: A wide range of technologies (including old and new user agents and assistive technologies) can access the content.

Acromyms POUR

Senmatic syntax
Every HTML form control, such as <input> and <textarea>, needs to be labeled accessibly. We need to provide descriptive labels that are also exposed to screen readers.

Although these standard HTML practices can be directly used in React, note that the for attribute is written as htmlFor in JSX:

<label htmlFor="namedInput">Name:</label>
<input id="namedInput" type="text" name="name"/>


Code Splitting
Bundling is great, but as your app grows, your bundle will grow too. Especially if you are including large third-party libraries. You need to keep an eye on the code you are including in your bundle so that you don’t accidentally make it so large that your app takes a long time to load.

To avoid winding up with a large bundle, it’s good to get ahead of the problem and start “splitting” your bundle. Code-Splitting is a feature supported by bundlers like Webpack, Rollup and Browserify (via factor-bundle) which can create multiple bundles that can be dynamically loaded at runtime.

import()
The best way to introduce code-splitting into your app is through the dynamic import() syntax.


 let  onloads  = async ()=>{
  await  import("./utils/makeUpperCase"/*webpackChunckName:utilitiesArrayToUpper*/).then(({makeUpperCase})=>{
          setUpc(makeUpperCase(['abe','table']))  
    })
  }


  React.lazy takes a function that must call a dynamic import(). This must return a Promise which resolves to a module with a default export containing a React component.

  The lazy component should then be rendered inside a Suspense component, which allows us to show some fallback content (such as a loading indicator) while we’re waiting for the lazy component to load.

import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}



Error boundaries
If the other module fails to load (for example, due to network failure), it will trigger an error. You can handle these errors to show a nice user experience and manage recovery with Error Boundaries. Once you’ve created your Error Boundary, you can use it anywhere above your lazy components to display an error state when there’s a network error.

const MyComponent = () => (
  <div>
    <MyErrorBoundary>
      <Suspense fallback={<div>Loading...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </MyErrorBoundary>
  </div





Route-based code splitting

A good place to start is with routes. Most people on the web are used to page transitions taking some amount of time to load. You also tend to be re-rendering the entire page at once so your users are unlikely to be interacting with other elements on the page at the same time.

Here’s an example of how to setup route-based code splitting into your app using libraries like React Router with React.lazy.


import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

const Home = lazy(() => import('./routes/Home'));
const About = lazy(() => import('./routes/About'));

const App = () => (
  <Router>
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  </Router>
);

Context
Context provides a way to pass data through the component tree without having to pass props down manually at every level.


When to Use Context
Context is designed to share data that can be considered “global” for a tree of React components, such as the current authenticated user, theme, or preferred language. For example, in the code below we manually thread through a “theme” prop in order to style the Button component:

Using context, we can avoid passing props through intermediate elements:


class MyClass extends React.Component {
  componentDidMount() {
    let value = this.context;
    /* perform a side-effect at mount using the value of MyContext */
  }
  componentDidUpdate() {
    let value = this.context;
    /* ... */
  }
  componentWillUnmount() {
    let value = this.context;
    /* ... */
  }
  render() {
    let value = this.context;
    /* render something based on the value of MyContext */
  }
}
MyClass.contextType = MyContext;

Context.Provider
<MyContext.Provider value={/* some value */}>
Every Context object comes with a Provider React component that allows consuming components to subscribe to context changes.

The Provider component accepts a value prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree

point ===> All consumers that are descendants of a Provider will re-render whenever the Provider’s value prop changes.

The propagation from Provider to its descendant consumers (including .contextType and useContext) is not subject to the shouldComponentUpdate method, so the consumer is updated even when an ancestor component skips an update.
Changes are determined by comparing the new and old values using the same algorithm as Object.is

Error boundaries 

Error boundaries do not catch errors for:

Event handlers (learn more)
Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)
Server side rendering
Errors thrown in the error boundary itself (rather than its children)

Class component have to implement
static getDerivedStateFromError() and componentDidCatch()
method to catch error
 Use static getDerivedStateFromError() to render a fallback UI after an error has been thrown. 
 Use componentDidCatch() to log error information.



class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // You can also log the error to an error reporting service
    logErrorToMyService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children; 
  }
}

Then you can use it as a regular component:
<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
try / catch is great but it only works for imperative code:

However, React components are declarative and specify what should be rendered:

Error boundaries preserve the declarative nature of React,

and behave as you would expect. For example, even if an error occurs in a componentDidUpdate method caused by a setState somewhere deep in the tree, it will still correctly propagate to the closest error boundary.

Error boundaries do not catch errors inside event handlers.

React doesn’t need error boundaries to recover from errors in event handlers. Unlike the render method and lifecycle methods, the event handlers don’t happen during rendering

If you need to catch an error inside an event handler, use the regular JavaScript try / catch statement:

Forwarding Refs


Higher-Order Components
A higher-order component (HOC) is an advanced technique that emerges from React’s compositional nature.

Concretely, a higher-order component is a function that takes a component and returns a new component.
Whereas a component transforms props into UI, a higher-order component transforms a component into another component.

Components are the primary unit of code reuse in React

Note that a HOC doesn’t modify the input component, nor does it use inheritance to copy its behavior. Rather, a HOC composes the original component by wrapping it in a container component. A HOC is a pure function with zero side-effects.

EnchaceComponent /aka newComponent/ = HigherOrderComponent( OriginalComponent())


Fragment => children grouping without adding node // it solve problem of adding extra node

shallow comparison is ===

PureComponent (re-render if state or props change (implement shouldComponentUpdate)) is for class component 

Memo is for function component

Ref make accessing react node possible


const loggerMiddleware = (store) => (next) => (action) => {
  // your code
};
the code above is the same as the code below
const loggerMiddleware = function (store) {
  return function (next) {
    return function (action) {
      // your code
    };
  };
};

Once the middleware function is created, we pass it to the applyMiddleware function like this:

const middleware = applyMiddleware(loggerMiddleware);

const store = createStore(reducer, middleware);
The word "thunk" is a programming term that means "a piece of code that does some delayed work". Rather than execute some logic now, we can write a function body or code that can be used to perform the work later.

"thunks" are a pattern of writing functions with logic inside that can interact with a Redux store's dispatch and getState methods.

const thunkFunction = (dispatch, getState) => {
  // logic here that can dispatch actions or read state
}

store.dispatch(thunkFunction)













backend/Lib/Config/keys/dev/KeyDev.js

sudo systemctl enable nginx   => system run nginx atomatically when bootup 

The service which is already listening on port 80 might be Apache or any other web server listening on port 80
sudo netstat -plant | grep 80
sudo systemctl stop apache2
sudo nano../../var/www/html/index.html

cd etc/nginx/sites-available
sudo apt-get install ngnix
sudo touch /etc/nginx/sites-available/app.conf
sudo nano /etc/nginx/sites-available/app.conf
sudo ln -s /etc/nginx/sites-available/app.conf /etc/nginx/sites-enabled/app.conf
sudo unlink /etc/nginx/sites-enabled/default.conf
sudo cat etc/nginx/nginx.conf
sudo vim /etc/nginx/sites-available/app.conf
sudo service ngnix restart
sudo rm /etc/nginx/sites-available/default
sudo apt-get -y install net-tools
sudo ln -s /etc/nginx/sites-available/default /etc/nginx/sites-enabled/default
config file is valid
sudo nginx -t
sudo cat etc/nginx/nginx.conf
sudo ufw app list
sudo ufw allow 'Nginx HTTP'
sudo ufw enable
sudo rm -f etc/nginx/sites-enabled/default etc/nginx/sites-enabled/default.conf

sudo service nginx restart
sudo systemctl status nginx
sudo systemctl stop nginx
sudo systemctl enable nginx
sudo systemctl status apache2
sudo cp etc/nginx/sites-available/site-configs etc/nginx/
sudo unlink -f etc/nginx/sites-enabled/site-configs

sudo npm install pm2 --location=global    install process manager

sudo service nginx reload

sudo fuser -k 80/tcp
sudo fuser -k 443/tcp
http://20.164.39.60/

sudo ln -s /etc/nginx/sites-{available,enabled}/default

sudo service nginx configtest
sudo apt purge nginx nginx-common nginx-core
sudo apt autoremove
scp -i pulic key dir/pblickey.pem -t ./dirlocaltocpy user@ipaddress:/home/user/destination/
mongodb+srv://adio:Bch2009021@portal.c57es.mongodb.net/chatDb?authSource=admin&replicaSet=portal-shard-0&readPreference=primary&ssl=true

/var/log/nginx/access.log
pm2 stop home/azeez/nodeapp/backend/server.js
pm2 start /home/azeez/nodeapp/backend/server.js --watch -- --port 7000

sudo nano /home/azeez/nodeapp/backend/server.js
sudo vim home/azeez/nodeapp/backend/server.js

curl -4 icanhazip.com know your ip public address

-p flag to create any necessary parent directories:

sudo mkdir -p /var/www/your_domain/html

Next, assign ownership of the directory with the $USER environment variable:

sudo chown -R $USER:$USER /var/www/your_domain/html   ($USER = variable that hold username;)
chown -R $USER:GROUP FOLDER (user and group should become owner of the folder)
To ensure that your permissions are correct and allow the owner to read, write, and execute the files while granting only read and execute permissions to groups and others, you can input the following command:

sudo chown -R $USER:$USER /var/www/your_domain9(is the folder name)/html change the owner
sudo chmod -R 755 /var/www/your_domain change the permission

sudo nano /etc/nginx/sites-available/your_domain

server {
        listen 80;
        listen [::]:80;

        root /home/azeez/nodeapp/frontend/build;
        index index.html index.htm index.nginx-debian.html;

        server_name 20.164.39.60;

        location / {
                try_files $uri $uri/ =404;
        }

        location /api/ { #where your backend is located not dir, is prefix url to backend
         proxy_pass http://20.164.39.60:7000;
         proxy_http_version 1.1;
         proxy_set_header Connection '';
         proxy_set_header Host $host;
         proxy_set_header X-Forwarded-Proto $scheme;
         proxy_set_header X-Real-IP $remote_addr;
         proxy_set_header X-Forwarded-For $remote_addr;
    }
}
sudo ln -s /etc/nginx/sites-available/your_domain /etc/nginx/sites-enabled/

To avoid a possible hash bucket memory problem that can arise from adding additional server names, it is necessary to adjust a single value in the /etc/nginx/nginx.conf file. Open the file:



sudo nano /etc/nginx/nginx.conf


Find the server_names_hash_bucket_size directive and remove the # symbol to uncomment the line. If you are using nano, you can quickly search for words in the file by pressing CTRL and w.

sudo nginx -t
sudo systemctl restart nginx
/var/log/nginx/access.log

















