Principles of Software Engineering that may be used in all phases of software development are the following:

Rigor and formality
Separation of concerns
Modularity and decomposition
Abstraction
Anticipation of change
Generality
Incremental Development
Reliability

SOLID principles (FOR OOP)




(S)Single responsibility 
        every module or class should have responsibility for a single part of the 
        functionality provided by the software and that
        responsibility should be entirely encapsulated by the class;
        

(O)Open-closed
         software entities (classes, modules, functions, etc.) should be open for extension,
          but closed for modification;
          Add behavior to component without changing the component
          (if else statement violet this principle)

(L)Liskov substitution:
        the inherited class should complement, not replace, the behavior of the base class
        If it is giving any type it should be able to handle it without braking the application.
        It states that objects of a superclass should be replaceable with objects of a subclass without 
        affecting the correctness of the program
        In other words, a subclass should be able to substitute its superclass in any context without 
        altering the desired behavior of the program.
        (When a class extends another class, they are not of the same type)

(I)Interface segregation
        a class should not be forced to implement interfaces it does not use
        In other words, instead of having a single large interface, it's better to have multiple smaller interfaces 
        that are specific to the needs of each class.

(D)Dependency inversion
        programmer should work at the interface level and not at the implementation level.
        it  encourages the use of abstractions (interfaces or abstract classes) to decouple higher-level modules 
        from lower-level implementation details.

        ``` 
        Suppose we have a ReportGenerator class that generates different types of reports, such as PDF and CSV reports. We want to ensure that the ReportGenerator class is not directly dependent on the low-level details of the report generation (e.g., PDF or CSV implementation). Instead, it should depend on abstractions, allowing us to easily swap out the report generation implementation without affecting the ReportGenerator class.

        Incorrect Approach (Violating DIP):

        php
  
        class PDFReportGenerator {
        public function generate() {
                // Generate PDF report
        }
        }

        class CSVReportGenerator {
        public function generate() {
                // Generate CSV report
        }
        }

        class ReportGenerator {
        private $pdfGenerator;
        private $csvGenerator;

        public function __construct() {
                $this->pdfGenerator = new PDFReportGenerator();
                $this->csvGenerator = new CSVReportGenerator();
        }

        public function generatePDFReport() {
                $this->pdfGenerator->generate();
        }

        public function generateCSVReport() {
                $this->csvGenerator->generate();
        }
        }
        In this incorrect approach, the ReportGenerator class directly 
        depends on the concrete implementations PDFReportGenerator and CSVReportGenerator. 
        This tight coupling makes it difficult to change or extend the report generation 
        logic without modifying the ReportGenerator class.
        



        Correct Approach (Applying DIP):

        php
  
        interface ReportGeneratorInterface {
        public function generate();
        }

        class PDFReportGenerator implements ReportGeneratorInterface {
        public function generate() {
                // Generate PDF report
        }
        }

        class CSVReportGenerator implements ReportGeneratorInterface {
        public function generate() {
                // Generate CSV report
        }
        }

        class ReportGenerator {
        private $reportGenerator;

        public function __construct(ReportGeneratorInterface $reportGenerator) {
                $this->reportGenerator = $reportGenerator;
        }

        public function generateReport() {
                $this->reportGenerator->generate();
        }
        }
        In this correct approach, we define an interface ReportGeneratorInterface 
        that declares the generate() method. Both PDFReportGenerator and CSVReportGenerator 
        classes implement this interface. The ReportGenerator class now depends on the abstraction
        (ReportGeneratorInterface) instead of concrete implementations. 
        This allows us to inject any implementation of ReportGeneratorInterface into 
        ReportGenerator, making it easy to switch report generation logic without
        modifying the ReportGenerator class.
        ```

Testing automation 
  Unit => Intration => System => Acceptance (test)