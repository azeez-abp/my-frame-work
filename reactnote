\
MAIN CONCEPTS
1. Hello World
2. Introducing JSX
3. Rendering Elements
4. Components and Props
5. State and Lifecycle
6. Handling Events
7. Conditional Rendering
8. Lists and Keys
9. Forms
10. Lifting State Up
11. Composition vs Inheritance
12. Thinking In React

eact is an open-source JavaScript library developed by the team at Facebook. It is used to build rich graphical user interfaces (UIs). It is based on the concept of reusable components, which allows you to create complex UIs out of small isolated pieces of code called components.


JSX stands for JavaScript syntax extension. It is a JavaScript extension that allows us to describe React's object tree using a syntax that resembles that of an HTML template. It is just an XML-like extension that allows us to write JavaScript that looks like markup and have it returned from a component



Because JSX is not valid JavaScript, browsers can’t read it directly; they do not know what to do with it, so we need a transpiler to translate it to React.createElement() calls. We need transpilers (a compiler that translates one form of syntax into another) like Babel or TypeScript to compile JSX into a browser-compatible version

The Virtual Dom
React uses Virtual DOM, which can be thought of as a blueprint of the DOM. When any changes are made to React elements, the Virtual DOM is updated. The Virtual DOM finds the differences between it and the DOM and re-renders only the elements in the DOM that changed. This makes the Virtual DOM faster and more efficient than updating the entire DOM.

rendering logic is inherently coupled with other UI logic
how events are handled, how the state changes over time, and how the data is prepared for display

Why JSX(to put markup and its logic togther in a component in a file)
Instead of artificially separating technologies by putting markup and logic in separate files, React separates concerns with loosely coupled units called “components” that contain both

JSX Prevents Injection Attacks
It is safe to embed user input in JSX:By default, React DOM escapes any values embedded in JSX before rendering them

These two examples are identical:

const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);

React.createElement() performs a few checks to help you write bug-free code but essentially it creates an object like this:

// Note: this structure is simplified
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
};
These objects above are called “React elements”
You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.


/////////////////////////////////////////////////////////////////////Section two

Rendering Elements
Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the browser DOM to match the React elements

Rendering an Element into the DOM(=> React.createRoot().render(element))
Let’s say there is a <div> somewhere in your HTML file:

<div id="root"></div>
To render a React element, 
first pass the DOM element to ReactDOM.createRoot(), 
then pass the React element to root.render():

const root = ReactDOM.createRoot(
  document.getElementById('root')
);
const element = <h1>Hello, world</h1>;
root.render(element);


We call this a “root” DOM node because everything inside it will be managed by React DOM(The Document Object Model [there is a document i.e. file; there is an Object <tags > on the document ; then model mode it i.e build it] is a cross-platform and language-independent interface that treats an XML or HTML document as a tree structure) (DOM model(build) object on ducument)

The Document Object Model (DOM) is a programming interface for web documents. It represents the page so that programs can change the document structure, style, and content. The DOM represents the document as nodes and objects

A web page is a document that can be either displayed in the browser window or as the HTML source. In both cases, it is the same document but the Document Object Model (DOM) representation allows it to be manipulated. As an object-oriented representation of the web page, it can be modified with a scripting language such as JavaScript.

The DOM was designed to be independent of any particular programming language, making the structural representation of the document available from a single, consistent API. Even if most web developers will only use the DOM through JavaScript, implementations of the DOM can be built for any language, as this Python example demonstrates:

# Python DOM example
import xml.dom.minidom as m
doc = m.parse(r"C:\Projects\Py\chap1.xml")
doc.nodeName # DOM property of document object
p_list = doc.getElementsByTagName("para")


Updating the Rendered Element
React elements are immutable. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.

With our knowledge so far, the only way to update the UI is to create a new element, and pass it to root.render().


COMPONENT AND PROPS

Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.

function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
This function is a valid React component because it accepts a single “props” (which stands for properties) object argument with data and returns a React element. We call such components “function components” because they are literally JavaScript functions.

Rendering a Component (Component is render as user-defined DOM <Welcome />)

State allows React components to change their output over time in response to user actions, network responses, and anything else

State and Lifecycle (of react component)

Converting a Function to a Class
You can convert a function component like Clock to a class in five steps:

Create an ES6 class, with the same name, that extends React.Component.
Add a single empty method to it called render().
Move the body of the function into the render() method.
Replace props with this.props in the render() body.
Delete the remaining empty function declaration.

class Clock extends React.Component {
  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}

Adding Lifecycle Methods to a Class
In applications with many components, it’s very important to free up resources taken by the components when they are destroyed
We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React.

We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React.

We can declare special methods on the component class to run some code when a component mounts and unmounts:
lifecycle methods”.
componentDidMount() {
  }
The componentDidMount() method runs after the component output has been rendered to the DOM. This is a good place to set up a timer:

  ///what is in between////////

  ////////

  componentWillUnmount() {
   function to run before component is removed from the dom
  }


  The Data Flows Down
  A component may choose to pass its state(which is private to every component) down as props to its child components:

Handling Events

Handling events with React elements is very similar to handling events on DOM elements. There are some syntax differences:

React events are named using camelCase, rather than lowercase.
With JSX you pass a function as the event handler, rather than a string.
For example, the HTML:

<button onclick="activateLasers()">
  Activate Lasers
</button>
is slightly different in React:

<button onClick={activateLasers}>
  Activate Lasers
</button>
  this.setState(function( prevState) {
        console.log( prevState)
          return  {isToggleOn: !prevState.isToggleOn}
    });
Conditional rendering(assigning element to variable let p  = <p>{this.state.data}<p>)
    Element Variables
You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn’t change

Lifting State Up (function and properties pass as props through polymorphism and compostion)
Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let’s see how this works in action.

Use concept of PoyMorhp (A Singgle Class, Instantiated severall time behave differently for the same method call)

Composition vs Inheritance
React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.

create-react-app includes built tools such as webpack, Babel, and ESLint.

/*

How does React Work?
React creates a VIRTUAL DOM in memory.

Instead of manipulating the browser's DOM directly, React creates a virtual DOM in memory, where it does all the necessary manipulating, before making the changes in the browser DOM.

React only changes what needs to be changed!

React finds out what changes have been made, and changes only what needs to be changed.

You will learn the various aspects of how React does this in the rest of this tutorial.

What is JSX?
JSX stands for JavaScript XML.

JSX allows us to write HTML in React.

JSX makes it easier to write and add HTML in React

JSX allows us to write HTML elements in JavaScript and place them in the DOM without any createElement()  and/or appendChild() methods.

JSX converts HTML tags into react elements.

//////////////////////////////////////////////////
example with JSX:

const myElement = <h1>I Love JSX!</h1>;

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(myElement);


Without JSX:

const myElement = React.createElement('h1', {}, 'I do not use JSX!');

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(myElement)
With JSX you can write expressions inside curly braces {javascript executable }.

without JSX writting react will be difficult
///////////////////////////////////////
Components are like functions or classes that return HTML elements.
Components are independent and reusable bits of code

Props are arguments passed into React components.

Props are passed to components via HTML attributes.

Using memo will cause React to skip rendering a component if its props have not changed.

This can improve performance (Memo is use for an application component the component will be wrapted in momo and  exported; memo(Component) )

Hooks allow function components to have access to state and other React features. Because of this, class components are generally no longer needed.

Although Hooks generally replace class components, there are no plans to remove classes from React.

Hooks allow us to "hook" into React features such as state and lifecycle methods.

There are 3 rules for hooks:

Hooks can only be called inside React function components.
Hooks can only be called at the top level of a component.
Hooks cannot be conditional

The useEffect Hook allows you to perform side effects in your components.

Some examples of side effects are: fetching data, directly updating the DOM, and timers.

useEffect(<function>, <dependency>)


Thinking in React
1. Start With A Mock
2. Break The UI Into A Component Hierarchy
3. Build A Static Version in React
4. Identify The Minimal (but complete) Representation Of UI State
5. Identify Where Your State Should Live
6. Add Inverse Data Flow
*/


The componentDidMount() method runs after the component output has been rendered to the DOM. This is a good place to set up a timer:

Component => Constructor => state => render=>(out is render into the dom)=>componentDidMount() =>shuoldComponetUpdate()=>componentWillUnmount()=> 


Mount => ['constructor', 'static getDerivedStateFromProps',  'render', 'componentDidMount']

Updating=>['static getDerivedStateFromProps','shouldComponentUpdate','render','getShapShotBeforeUpdare','componentDidUpdate']

unmounting => ['componentWillUnmount']

Error Handling =>['static getDerivedStateFromError','componentDidCatch']


constructor(props)
////////////////////////////////////////////////////
static getDerivedStateFromProps(props,state)
componentDidMount()
shouldComponentUpdate(nextProps,nextState) if return false, no re-render 
getShapShotBeforeUpdare(prevProps,prevState)
componentDidUpdate(prevProps,prevState,snapSHotReturnValue)
//////////////////////////////////////////////////////////////


order of execution
1. constructor

2. static getDerivedStateFromProps

3. render

4. componentDidMount

useState =>to state
useContext =>context Api
useEffect =>side effect (fetching data)
userReducer =>reducer (Array.reduce)

6|uJN0qBBrwjZgKr6ZBNeYgUCLcXrzplrtQitAt6up
6|XBTjsV4CZs8DEg7EJZCv5IsUjEnjDnl6OzvzRVJY